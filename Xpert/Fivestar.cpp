/*
비어있는 높이 N, 너비 M의 격자 판이 있다(비어있는 공간은 '.'로 표기한다.)

이러한 격자판에 ‘*****’가 새겨진 막대를 이용하여 입력받은 패턴을 재현할 수 있는지 없는지 판단하고,

가능 할 경우 사용되는 막대의 최소 개수를 알아내는 프로그램을 제작하고자 한다.

막대에 새겨진 한 글자와 격자 판의 한 칸의 크기는 일치한다.

막대는 격자 판 내에 놓여야 하며, 수는 제한이 없다.

막대끼리 겹칠 수 있으며, 수직으로, 수평으로만 놓을 수 있다.



아래와 같은 패턴이 입력되었을 경우 2번째 열에 수직으로 막대를 하나,

2번째 행에 두 번째 열에 수평으로 막대를 하나,

마지막으로 4번째 행 첫 번째 열에 수평으로 막대를 하나 놓게 되면 3개의 막대로 패턴을 완성시킬 수 있다.



.*....

.*****

.*....

*****.

.*....

첫줄에는 격자판의 높이 N 너비 M이 입력된다(1≤N≤5, 1≤M≤10).

그 다음 줄부터 N x M 크기의 패턴이 입력된다.

비어있는 칸은 ‘.’로 채워져야 하는 칸은 ‘*’로 표시한다.

입력된 패턴을 만들 수 없을 경우 -1을

0개 이상의 "*****"가 새겨진 막대로 만들 수 있는 경우 사용되는 막대의 최소 개수를 출력한다.

5 6
.*....
.*****
.*....
*****.
.*....

3
*/

/*

풀이 : 세로로는 최대 1개 들어올 수 있고 가로로는 최대 2개 들어올 수 있다.
열마다 *의 갯수를 각각 세주고 행마다 *의 누적합을 구한다.  
그래서 열에서 세로 기둥을 세웠을 때 모든 경우(dfs) 에다가 가로로 최대 5개까지 세본다.
누적합이므로 5개를 세기 전에 조건이 어긋났는데 5개 이상이 있다면 거기에다가 막대를 놓을 수 있단 소리다.
그리고 막대의 마지막 다음 위치부터 다시 카운트를 한다.
코드를 다시 분석하면 최적인 경우임을 알 수 있을 것이다.

*/

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int n,m;
char arr[11][11];
int row[6];
int col[11][11];
int used[11];
int mini = 1e9;

int calc()
{
	
	int cnt = 0;
	int i, j, r;

	for (i = 0; i < n; i++)
	{
		for (j = 0; j < m; j++)
		{
			if (col[i][j] && !used[j]) //일단 세로 기둥 없는 데 부터 세고싶어. 하지만 이 코드에서 세로 기둥과 겹치는게 최적이라고 쳐도 누적합 덕분에 겹치는 경우도 체크할 수 있다!!
			{
				for (r = j; r < j + 5 && r < m && col[i][r]; r++);
				j = r - 1;

				if (col[i][j] >= 5)
					cnt++;
				else
					return -1;
			}
			
		}
	}


	return cnt;
}

void dfs(int cnt,int col)
{
	if (col >= m)
	{
		int cal = calc();
		if (cal == -1)
		{

		}
		else
		{
			if (mini > cal + cnt)
			{
				mini = cal+cnt;
			}
		}
		return;
	}

	if (row[col] == 5)
	{
		used[col] = 1;
		dfs(cnt+1, col + 1);
		used[col] = 0;
	}
	dfs(cnt,col + 1);

}


int main() 
{
	scanf("%d %d", &n,&m);
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			scanf(" %c", &arr[i][j]);
			if (arr[i][j] == '*')
			{
				col[i][j] = col[i][j - 1] + 1;
				row[j]++;
			}
		}
	}


	dfs(0, 0);
	if (mini == 1e9)
		printf("-1");
	else
		printf("%d", mini);
	return 0;
}
