//https://www.acmicpc.net/problem/14927
/*x좌표가 같으면 y좌표는 가장 작은 좌표, 가장 큰 좌표만 보면 된다. 이전 x좌표의 가장 작은 y에서
올라온건지, 가장 큰 y에서 올라온건지 경우를 나눠 현재 신호의 길이를 더한다.(자료형 주의......)*/
#include <stdio.h>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
#include <math.h>
using namespace std;

map <int, int> mmin;
map <int, int> mmax;

int main() {

	ios_base::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		auto iter = mmax.find(a);
		auto iter2 = mmin.find(a);
		if (iter == mmax.end())//아무것도 없다
		{
			mmax[a] = b;
			mmin[a] = b;
		}
		else
		{
			if (iter->second < b)
			{
				mmax[a] = b;
			}
			if (iter2->second > b)
			{
				mmin[a] = b;

			}
		}
	}
	
	auto iter = mmax.begin();
	
	int past = iter->first;
	iter++;
	double num1 = 0;
	double num2 = 0;
	double num3 = 0;
	double num4 = 0;
	double Max1 = 0, Max2 = 0;
	while (iter != mmax.end())
	{
		int now = iter->first;

		long long int res1 = (long long int)(now - past)*(now - past)
			+ (long long int) (mmax[now] - mmax[past])*(mmax[now] - mmax[past]);
		num1 = Max1+double(sqrt(res1));

		long long int res3 = (long long int)(now - past)*(now - past)
			+ (long long int)(mmin[now] - mmax[past])*(mmin[now] - mmax[past]);
		num3 = Max1+ double(sqrt(res3));

		long long int res2 = (long long int)(now - past)*(now - past)
			+ (long long int)(mmax[now] - mmin[past])*(mmax[now] - mmin[past]);
		num2 = Max2+ double(sqrt(res2));

		long long int res4 = (long long int)(now - past)*(now - past)
			+ (long long int)(mmin[now] - mmin[past])*(mmin[now] - mmin[past]);
		num4 = Max2+ double(sqrt(res4));

		Max1 = max(num1, num2);
		Max2 = max(num3, num4);

		past = now;
		iter++;
	}
	printf("%.10lf", max(Max1, Max2));
	return 0;
}
